{"message":"can't find crate for `proc_marco`","code":{"code":"E0463","explanation":"A plugin/crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\n#![feature(plugin)]\n#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`\nextern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc example). Plugins are crates as\nwell, and you link to them the same way.\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":24,"line_start":1,"line_end":1,"column_start":1,"column_end":25,"is_primary":true,"text":[{"text":"extern crate proc_marco;","highlight_start":1,"highlight_end":25}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0463]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: can't find crate for `proc_marco`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:1:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mextern crate proc_marco;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcan't find crate\u001b[0m\n\n"}
{"message":"failed to resolve: could not find `punctusted` in `syn`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":451,"byte_end":461,"line_start":15,"line_end":15,"column_start":25,"column_end":35,"is_primary":true,"text":[{"text":"    let fn_inputs: syn::punctusted::Punctuated<syn::FnArg, syn::token::Comms> = input.sig.inputs;","highlight_start":25,"highlight_end":35}],"label":"could not find `punctusted` in `syn`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: could not find `punctusted` in `syn`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:15:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let fn_inputs: syn::punctusted::Punctuated<syn::FnArg, syn::token::Comms> = input.sig.inputs;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `punctusted` in `syn`\u001b[0m\n\n"}
{"message":"cannot find type `Comms` in module `syn::token`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\chung\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\syn-2.0.28\\src\\token.rs","byte_start":11294,"byte_end":11310,"line_start":377,"line_end":377,"column_start":13,"column_end":29,"is_primary":false,"text":[{"text":"            pub struct $name {","highlight_start":13,"highlight_end":29}],"label":"similarly named struct `Comma` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\chung\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\syn-2.0.28\\src\\token.rs","byte_start":13397,"byte_end":13501,"line_start":443,"line_end":445,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            define_punctuation_structs! {","highlight_start":13,"highlight_end":42},{"text":"                $token pub struct $name/$len #[doc = $usage]","highlight_start":1,"highlight_end":61},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\chung\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\syn-2.0.28\\src\\token.rs","byte_start":23010,"byte_end":26580,"line_start":785,"line_end":832,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"define_punctuation! {","highlight_start":1,"highlight_end":22},{"text":"    \"&\"           pub struct And/1        /// bitwise and logical AND, borrow, references, reference patterns","highlight_start":1,"highlight_end":110},{"text":"    \"&&\"          pub struct AndAnd/2     /// lazy AND, borrow, references, reference patterns","highlight_start":1,"highlight_end":95},{"text":"    \"&=\"          pub struct AndEq/2      /// bitwise AND assignment","highlight_start":1,"highlight_end":69},{"text":"    \"@\"           pub struct At/1         /// subpattern binding","highlight_start":1,"highlight_end":65},{"text":"    \"^\"           pub struct Caret/1      /// bitwise and logical XOR","highlight_start":1,"highlight_end":70},{"text":"    \"^=\"          pub struct CaretEq/2    /// bitwise XOR assignment","highlight_start":1,"highlight_end":69},{"text":"    \":\"           pub struct Colon/1      /// various separators","highlight_start":1,"highlight_end":65},{"text":"    \",\"           pub struct Comma/1      /// various separators","highlight_start":1,"highlight_end":65},{"text":"    \"$\"           pub struct Dollar/1     /// macros","highlight_start":1,"highlight_end":53},{"text":"    \".\"           pub struct Dot/1        /// field access, tuple index","highlight_start":1,"highlight_end":72},{"text":"    \"..\"          pub struct DotDot/2     /// range, struct expressions, patterns, range patterns","highlight_start":1,"highlight_end":98},{"text":"    \"...\"         pub struct DotDotDot/3  /// variadic functions, range patterns","highlight_start":1,"highlight_end":81},{"text":"    \"..=\"         pub struct DotDotEq/3   /// inclusive range, range patterns","highlight_start":1,"highlight_end":78},{"text":"    \"=\"           pub struct Eq/1         /// assignment, attributes, various type definitions","highlight_start":1,"highlight_end":95},{"text":"    \"==\"          pub struct EqEq/2       /// equal","highlight_start":1,"highlight_end":52},{"text":"    \"=>\"          pub struct FatArrow/2   /// match arms, macros","highlight_start":1,"highlight_end":65},{"text":"    \">=\"          pub struct Ge/2         /// greater than or equal to, generics","highlight_start":1,"highlight_end":81},{"text":"    \">\"           pub struct Gt/1         /// greater than, generics, paths","highlight_start":1,"highlight_end":76},{"text":"    \"<-\"          pub struct LArrow/2     /// unused","highlight_start":1,"highlight_end":53},{"text":"    \"<=\"          pub struct Le/2         /// less than or equal to","highlight_start":1,"highlight_end":68},{"text":"    \"<\"           pub struct Lt/1         /// less than, generics, paths","highlight_start":1,"highlight_end":73},{"text":"    \"-\"           pub struct Minus/1      /// subtraction, negation","highlight_start":1,"highlight_end":68},{"text":"    \"-=\"          pub struct MinusEq/2    /// subtraction assignment","highlight_start":1,"highlight_end":69},{"text":"    \"!=\"          pub struct Ne/2         /// not equal","highlight_start":1,"highlight_end":56},{"text":"    \"!\"           pub struct Not/1        /// bitwise and logical NOT, macro calls, inner attributes, never type, negative impls","highlight_start":1,"highlight_end":129},{"text":"    \"|\"           pub struct Or/1         /// bitwise and logical OR, closures, patterns in match, if let, and while let","highlight_start":1,"highlight_end":121},{"text":"    \"|=\"          pub struct OrEq/2       /// bitwise OR assignment","highlight_start":1,"highlight_end":68},{"text":"    \"||\"          pub struct OrOr/2       /// lazy OR, closures","highlight_start":1,"highlight_end":64},{"text":"    \"::\"          pub struct PathSep/2    /// path separator","highlight_start":1,"highlight_end":61},{"text":"    \"%\"           pub struct Percent/1    /// remainder","highlight_start":1,"highlight_end":56},{"text":"    \"%=\"          pub struct PercentEq/2  /// remainder assignment","highlight_start":1,"highlight_end":67},{"text":"    \"+\"           pub struct Plus/1       /// addition, trait bounds, macro Kleene matcher","highlight_start":1,"highlight_end":91},{"text":"    \"+=\"          pub struct PlusEq/2     /// addition assignment","highlight_start":1,"highlight_end":66},{"text":"    \"#\"           pub struct Pound/1      /// attributes","highlight_start":1,"highlight_end":57},{"text":"    \"?\"           pub struct Question/1   /// question mark operator, questionably sized, macro Kleene matcher","highlight_start":1,"highlight_end":111},{"text":"    \"->\"          pub struct RArrow/2     /// function return type, closure return type, function pointer type","highlight_start":1,"highlight_end":111},{"text":"    \";\"           pub struct Semi/1       /// terminator for various items and statements, array types","highlight_start":1,"highlight_end":103},{"text":"    \"<<\"          pub struct Shl/2        /// shift left, nested generics","highlight_start":1,"highlight_end":74},{"text":"    \"<<=\"         pub struct ShlEq/3      /// shift left assignment","highlight_start":1,"highlight_end":68},{"text":"    \">>\"          pub struct Shr/2        /// shift right, nested generics","highlight_start":1,"highlight_end":75},{"text":"    \">>=\"         pub struct ShrEq/3      /// shift right assignment, nested generics","highlight_start":1,"highlight_end":86},{"text":"    \"/\"           pub struct Slash/1      /// division","highlight_start":1,"highlight_end":55},{"text":"    \"/=\"          pub struct SlashEq/2    /// division assignment","highlight_start":1,"highlight_end":66},{"text":"    \"*\"           pub struct Star/1       /// multiplication, dereference, raw pointers, macro Kleene matcher, use wildcards","highlight_start":1,"highlight_end":125},{"text":"    \"*=\"          pub struct StarEq/2     /// multiplication assignment","highlight_start":1,"highlight_end":72},{"text":"    \"~\"           pub struct Tilde/1      /// unused since before Rust 1.0","highlight_start":1,"highlight_end":75},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"define_punctuation!","def_site_span":{"file_name":"C:\\Users\\chung\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\syn-2.0.28\\src\\token.rs","byte_start":13255,"byte_end":13286,"line_start":440,"line_end":440,"column_start":1,"column_end":32,"is_primary":false,"text":[{"text":"macro_rules! define_punctuation {","highlight_start":1,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"define_punctuation_structs!","def_site_span":{"file_name":"C:\\Users\\chung\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\syn-2.0.28\\src\\token.rs","byte_start":10772,"byte_end":10811,"line_start":364,"line_end":364,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! define_punctuation_structs {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\lib.rs","byte_start":498,"byte_end":503,"line_start":15,"line_end":15,"column_start":72,"column_end":77,"is_primary":true,"text":[{"text":"    let fn_inputs: syn::punctusted::Punctuated<syn::FnArg, syn::token::Comms> = input.sig.inputs;","highlight_start":72,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":498,"byte_end":503,"line_start":15,"line_end":15,"column_start":72,"column_end":77,"is_primary":true,"text":[{"text":"    let fn_inputs: syn::punctusted::Punctuated<syn::FnArg, syn::token::Comms> = input.sig.inputs;","highlight_start":72,"highlight_end":77}],"label":null,"suggested_replacement":"Comma","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `Comms` in module `syn::token`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:15:72\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let fn_inputs: syn::punctusted::Punctuated<syn::FnArg, syn::token::Comms> = input.sig.inputs;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a struct with a similar name exists: `Comma`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m::: \u001b[0m\u001b[0mC:\\Users\\chung\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\syn-2.0.28\\src\\token.rs:785:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m785\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdefine_punctuation! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m786\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"&\"           pub struct And/1        /// bitwise and logical AND, borrow, references, reference patterns\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m787\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"&&\"          pub struct AndAnd/2     /// lazy AND, borrow, references, reference patterns\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m788\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"&=\"          pub struct AndEq/2      /// bitwise AND assignment\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m831\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"~\"           pub struct Tilde/1      /// unused since before Rust 1.0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m832\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14msimilarly named struct `Comma` defined here\u001b[0m\n\n"}
{"message":"aborting due to 3 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 3 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0412, E0433, E0463.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0412, E0433, E0463.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0412`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0412`.\u001b[0m\n"}
